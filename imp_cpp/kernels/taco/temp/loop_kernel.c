// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "x(i) = y(i)" -f=x:d:0 -f=y:d:0 -t=x:double -t=y:double -write-source=loop_kernel.c -write-compute=loop_compute.c -write-assembly=loop_assembly.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <complex.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
#endif

int assemble(taco_tensor_t *x, taco_tensor_t *y) {
  int x1_dimension = (int)(x->dimensions[x->mode_ordering[0]]);
  double* restrict x_vals = (double*)(x->vals);
  int x_vals_size = x->vals_size;
  int y1_dimension = (int)(y->dimensions[y->mode_ordering[0]]);
  for (int32_t iy = 0; iy < y1_dimension; iy++) {
  }

  x_vals = (double*)malloc(sizeof(double) * x1_dimension);
  x_vals_size = x1_dimension;
  x->vals = (uint8_t*)x_vals;
  x->vals_size = x_vals_size;
  return 0;
}

int compute(taco_tensor_t *x, taco_tensor_t *y) {
  double* restrict x_vals = (double*)(x->vals);
  int y1_dimension = (int)(y->dimensions[y->mode_ordering[0]]);
  double* restrict y_vals = (double*)(y->vals);
  #pragma omp parallel for
  for (int32_t iy = 0; iy < y1_dimension; iy++) {
    x_vals[iy] = y_vals[iy];
  }
  return 0;
}
