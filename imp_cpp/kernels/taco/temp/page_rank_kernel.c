// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// taco "y(i) = alpha * (A(i, j) * x(j)) + z(i)" -f=A:ss:0,1 -f=x:d:0 -f=z:d:0 -f=y:d:0 -t=A:double -t=x:double -t=z:double -t=y:double -write-source=page_rank_kernel.c -write-compute=page_rank_compute.c -write-assembly=page_rank_assembly.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <complex.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
#endif

int assemble(taco_tensor_t *y, taco_tensor_t *alpha, taco_tensor_t *A, taco_tensor_t *x, taco_tensor_t *z) {
  int y1_dimension = (int)(y->dimensions[y->mode_ordering[0]]);
  double* restrict y_vals = (double*)(y->vals);
  int y_vals_size = y->vals_size;
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A1_coord = (int*)(A->indices[0][1]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  int* restrict A2_coord = (int*)(A->indices[1][1]);
  int z1_dimension = (int)(z->dimensions[z->mode_ordering[0]]);
  int32_t pA1 = A1_pos[0];
  int32_t A1_end = A1_pos[1];
  int32_t iz = 0;
  int32_t z1_end = z1_dimension;
  while (pA1 < A1_end) {
    int32_t iA = A1_coord[pA1];
    int32_t pz1 = iz;
    int32_t py1 = iz;
    if (iA == iz) {
      for (int32_t pA2 = A2_pos[pA1]; pA2 < A2_pos[(pA1 + 1)]; pA2++) {
        int32_t jA = A2_coord[pA2];
      }
    }
    else {
    }
    pA1 += (int32_t)(iA == iz);
    iz++;
  }
  while (iz < z1_end) {
    int32_t pz1 = iz;
    int32_t py1 = iz;
    iz++;
  }

  y_vals = (double*)malloc(sizeof(double) * y1_dimension);
  y_vals_size = y1_dimension;
  y->vals = (uint8_t*)y_vals;
  y->vals_size = y_vals_size;
  return 0;
}

int compute(taco_tensor_t *y, taco_tensor_t *alpha, taco_tensor_t *A, taco_tensor_t *x, taco_tensor_t *z) {
  int y1_dimension = (int)(y->dimensions[y->mode_ordering[0]]);
  double* restrict y_vals = (double*)(y->vals);
  double* restrict alpha_vals = (double*)(alpha->vals);
  int* restrict A1_pos = (int*)(A->indices[0][0]);
  int* restrict A1_coord = (int*)(A->indices[0][1]);
  int* restrict A2_pos = (int*)(A->indices[1][0]);
  int* restrict A2_coord = (int*)(A->indices[1][1]);
  double* restrict A_vals = (double*)(A->vals);
  double* restrict x_vals = (double*)(x->vals);
  int z1_dimension = (int)(z->dimensions[z->mode_ordering[0]]);
  double* restrict z_vals = (double*)(z->vals);
  for (int32_t py = 0; py < y1_dimension; py++) {
    y_vals[py] = 0;
  }
  int32_t pA1 = A1_pos[0];
  int32_t A1_end = A1_pos[1];
  int32_t iz = 0;
  int32_t z1_end = z1_dimension;
  while (pA1 < A1_end) {
    int32_t iA = A1_coord[pA1];
    int32_t pz1 = iz;
    int32_t py1 = iz;
    if (iA == iz) {
      double tj = 0;
      for (int32_t pA2 = A2_pos[pA1]; pA2 < A2_pos[(pA1 + 1)]; pA2++) {
        int32_t jA = A2_coord[pA2];
        tj += A_vals[pA2] * x_vals[jA];
      }
      y_vals[py1] = alpha_vals[0] * tj + z_vals[pz1];
    }
    else {
      y_vals[py1] = z_vals[pz1];
    }
    pA1 += (int32_t)(iA == iz);
    iz++;
  }
  while (iz < z1_end) {
    int32_t pz1 = iz;
    int32_t py1 = iz;
    y_vals[py1] = z_vals[pz1];
    iz++;
  }
  return 0;
}
